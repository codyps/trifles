## config.sh: 9979ecf, see https://github.com/jmesmon/cninja.git
# ex: sts=8 sw=8 ts=8 noet
set -eu

D="$(dirname "$0")"

: ${CROSS_COMPILER:=}
: ${HOST_CC:=cc}
: ${CC:=${CROSS_COMPILER}cc}
: ${OBJCOPY:=${CROSS_COMPILER}objcopy}

: ${PKGCONFIG:=pkg-config}
: ${WARN_FLAGS_C:="-Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition -Wmissing-declarations -Wbad-function-cast"}
: ${WARN_FLAGS:="-Wall -Wundef -Wshadow -Wcast-align -Wwrite-strings -Wextra -Werror=attributes -Wno-missing-field-initializers ${WARN_FLAGS_C}"}
: ${GIT_VER:=$(${GIT:-git} describe --dirty=+ --always 2>/dev/null || echo "+")}

if [ -n "${PKGCONFIG_LIBS:=}" ]; then
	PKGCONFIG_CFLAGS="$(${PKGCONFIG} --cflags ${PKGCONFIG_LIBS})"
	PKGCONFIG_LDFLAGS="$(${PKGCONFIG} --libs ${PKGCONFIG_LIBS})"
else
	PKGCONFIG_CFLAGS=""
	PKGCONFIG_LDFLAGS=""
fi

LIB_CFLAGS="${LIB_CFLAGS:-} ${PKGCONFIG_CFLAGS} "
LIB_LDFLAGS="${LIB_LDFLAGS:-} ${PKGCONFIG_LDFLAGS}"

ALL_CFLAGS="${WARN_FLAGS}"

if_runs () {
	local y="$1"
	local n="$2"
	shift 2
	"$@" >/dev/null 2>&1 && printf "%s" "$y" || printf "%s" "$n"
}

# Given a series of flags for CC, echo (space seperated) the ones that the
# compiler is happy with.
# XXX: Note that this does mean flags with spaces in them won't work.
cflag_x () {
	local cc=$(eval printf "%s" "\${$1CC}")
	local cflags=$(eval printf "%s" "\${$1CFLAGS:-}")
	shift
	for i in "$@"; do
		if_runs "$i " "" $cc $cflags -c -x c "$i" /dev/null -o /dev/null
	done
}

try_run() {
	"$@" >/dev/null 2>&1
}

cflag_first () {
	local cc=$(eval printf "%s" "\${$1CC}")
	local cflags=$(eval printf "%s" "\${$1CFLAGS:-}")
	shift
	for i in "$@"; do
		if try_run $cc $cflags -c -x c "$i" /dev/null -o /dev/null; then
			echo "$i"
			return
		fi
	done
}

die () {
	>&2 echo "Error: $*"
	exit 1
}

: ${EXTRA_FLAGS=}

: ${SANITIZE_FLAGS="$(cflag_x "" -fsanitize=address -fsanitize=undefined)"}
: ${DEBUG_FLAGS="$(cflag_x "" -ggdb3 -fvar-tracking-assignments)"}
: ${LTO_FLAGS="$(cflag_x "" -flto)"}
: ${OPT_FLAGS="$(cflag_first "" -Og -Os -O2)"}

COMMON_FLAGS="${SANITIZE_FLAGS} ${DEBUG_FLAGS} ${LTO_FLAGS}"

: ${CFLAGS="${ALL_CFLAGS} ${COMMON_FLAGS} ${OPT_FLAGS} ${EXTRA_FLAGS}"}

if [ -n "${LTO_FLAGS}" ]; then
	COMMON_FLAGS="${COMMON_FLAGS} ${OPT_FLAGS}"
fi

# Without LIB_CFLAGS
: ${HOST_CFLAGS:=${CFLAGS:-}}

CFLAGS="-DCFG_GIT_VERSION=${GIT_VER} -I. ${LIB_CFLAGS} ${CFLAGS:-}"

: ${LDFLAGS:="${COMMON_FLAGS}"}
LDFLAGS="${LIB_LDFLAGS} ${LDFLAGS} ${DEBUG_FLAGS}"

CONFIG_H_GEN=./config_h_gen

CONFIGS=""

# Check if compiler likes -MMD -MF
if $CC $CFLAGS -MMD -MF /dev/null -c -x c /dev/null -o /dev/null >/dev/null 2>&1; then
	DEP_LINE="  depfile = \$out.d"
	DEP_FLAGS="-MMD -MF \$out.d"
else
	DEP_LINE=""
	DEP_FLAGS=""
fi

exec >build.ninja
echo "# generated by config.sh"

cat <<EOF
cc = $CC
objcopy = $OBJCOPY
cflags = $CFLAGS
ldflags = $LDFLAGS

rule cc
  command = \$cc \$cflags $DEP_FLAGS  -c \$in -o \$out
$DEP_LINE

rule cc_fail
  command = ! \$cc \$cflags $DEP_FLAGS -c \$in -o \$out
$DEP_LINE

rule ccld
  command = \$cc \$ldflags -o \$out \$in

rule config_h_frag
  command = ${CONFIG_H_GEN} \$in \$cc \$cflags \$ldflags > \$out

rule combine
  command = cat \$in > \$out

rule ninja_gen
  command = $0
  generator = yes
EOF

CONFIGURE_DEPS="$0"

to_out () {
  for i in "$@"; do
    printf "%s " ".build-$out/$i"
  done
}

# <target> <src-file>...
to_obj () {
	local target="$1"
	shift
	for i in "$@"; do
		printf "%s " ".build-$target/$i.o"
	done
}

_ev () {
	eval echo "\${$1}"
}

config () {
	local configs=""
	for i in "$D"/config_h/*.c; do
		local name=".config.h-$i-frag"
		echo "build $name : config_h_frag $i | "$D"/if_compiles ${CONFIG_H_GEN}"
		configs="$configs $name"
	done

	echo "build config.h : combine $D/config_h/prefix.h $configs $D/config_h/suffix.h"
}

if [ -e "config_h" ]; then
	CONFIG_H=true
else
	CONFIG_H=false
fi

# If any files in config_h change, we need to re-generate build.ninja
if $CONFIG_H; then
	CONFIGURE_DEPS="$CONFIGURE_DEPS config_h/ ${CONFIG_H_GEN}"
fi

e_if() {
	v=$1
	shift
	if $v; then
		echo "$@"
	fi
}

# <target> <src> [<act>]
# uses: CONFIG_H
obj() {
	local target=$1
	local s=$2
	shift
	shift
	local act=cc
	if [ $# -ne 0 ]; then
		act=$1
		shift
	fi

	cat <<EOF
build $(to_obj "$target" "$s"): $act $s | $(e_if $CONFIG_H config.h)
  cflags = \$cflags -I.build-$target
EOF
}

bin () {
	if [ "$#" -lt 2 ]; then
		die "'bin $1' has to have some source"
	fi
	local out="$1"
	shift
	local out_var=$(printf '%s' "$out" | sed 's/./_/')

	for s in "$@"; do
		obj "$s" "$out"
	done

	cat <<EOF
build $out : ccld $(to_obj "$out" "$@")
EOF
	BINS="$BINS $out"
}
BINS=""

# <target-name> <path-to-dir>
add_test_dir() {
	local target="$1/test"
	local f="$2"
	for f in "$f"/*; do
		b="$(basename "$f")"
		case "$b" in
		compile*.c)
			obj "$target" "$f"
			echo "default $(to_obj "$target" "$f")"
			;;
		compile_fail*.c)
			obj "$target" "$f" cc_fail
			echo "default $(to_obj "$target" "$f")"
			;;
		run*.c)
			obj "$target" "$f"
			echo "default $(to_obj "$target" "$f")"
			>&2 echo "run test not supported, will only compile $f"
			;;
		api*.c)
			>&2 echo "api test not supported, skipped $f"
			;;
		esac
	done
}

add_module() {
	local m="$1"
	local f
	for f in "$D/$1"/*; do
		b="$(basename "$f")"
		if [ -d "$f" ]; then
			if [ "$b" = test ]; then
				add_test_dir "$m" "$f"
			else
				>&2 echo unknown dir $f
			fi
		else
			>&2 echo file $f
		fi
	done
}

end_of_ninja () {
	echo build build.ninja : ninja_gen $CONFIGURE_DEPS
	if [ -n "$BINS" ]; then
		echo default $BINS
	fi
}

trap end_of_ninja EXIT
